const TaiKhoan = require('../models/TaiKhoan');
const { NguoiDung } = require('../models/NguoiDung');
const OTP = require('../models/OTP');
const bcrypt = require('bcryptjs');
const twilio = require('twilio');
const mongoose = require('mongoose');

const twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

const findTaiKhoanBySdt = async (sdt) => {
    return TaiKhoan.findOne({ sdt });
};

const findNguoiDungById = async (id) => {
    // Validate ObjectId
    if (!id || !mongoose.Types.ObjectId.isValid(id)) {
        throw new Error('ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá');
    }
    return NguoiDung.findById(id);
};

const guiOTPQuenMatKhau = async (sdt) => {
    try {
        // B∆∞·ªõc 1: Ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i c√≥ t·ªìn t·∫°i trong h·ªá th·ªëng kh√¥ng
        console.log(`üîç Checking if phone number exists: ${sdt}`);
        const taiKhoan = await TaiKhoan.findOne({ sdt });

        if (!taiKhoan) {
            console.log(`‚ùå Phone number not found: ${sdt}`);
            throw new Error('S·ªë ƒëi·ªán tho·∫°i ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω.');
        }

        console.log(`‚úÖ Phone number found in system: ${sdt}`);

        // B∆∞·ªõc 2: Ki·ªÉm tra rate limiting - ch·ªâ cho ph√©p g·ª≠i OTP m·ªói 60 gi√¢y
        const recentOTP = await OTP.findOne({
            sdt,
            createdAt: { $gte: new Date(Date.now() - 60000) } // 60 gi√¢y
        });

        if (recentOTP) {
            console.log(`‚è∞ Rate limit: OTP sent too recently for ${sdt}`);
            throw new Error('Vui l√≤ng ƒë·ª£i 60 gi√¢y tr∆∞·ªõc khi y√™u c·∫ßu m√£ OTP m·ªõi.');
        }

        // B∆∞·ªõc 3: X√≥a c√°c OTP c≈© c·ªßa s·ªë ƒëi·ªán tho·∫°i n√†y (n·∫øu c√≥)
        await OTP.deleteMany({ sdt });
        console.log(`üßπ Cleaned old OTPs for: ${sdt}`);

        // B∆∞·ªõc 4: T·∫°o m√£ OTP m·ªõi (6 ch·ªØ s·ªë)
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        console.log(`üî¢ Generated OTP for ${sdt}: ${otp}`);

        // B∆∞·ªõc 5: L∆∞u OTP v√†o database
        const otpRecord = await OTP.create({ sdt, otp });
        console.log(`üíæ OTP saved to database with ID: ${otpRecord._id}`);

        // B∆∞·ªõc 6: G·ª≠i SMS qua Twilio
        let smsSuccess = false;
        let messageSid = null;

        try {
            // Ki·ªÉm tra c·∫•u h√¨nh Twilio tr∆∞·ªõc khi g·ª≠i
            if (!process.env.TWILIO_ACCOUNT_SID || !process.env.TWILIO_AUTH_TOKEN || !process.env.TWILIO_PHONE_NUMBER) {
                throw new Error('C·∫•u h√¨nh Twilio ch∆∞a ƒë·∫ßy ƒë·ªß. Vui l√≤ng ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng.');
            }

            // Format s·ªë ƒëi·ªán tho·∫°i: 0329982474 -> +84329982474
            let sdtQuocTe = sdt;
            if (sdt.startsWith('0')) {
                sdtQuocTe = `+84${sdt.substring(1)}`;
            } else if (!sdt.startsWith('+')) {
                sdtQuocTe = `+84${sdt}`;
            }

            // Validate s·ªë ƒëi·ªán tho·∫°i
            if (!/^\+84[0-9]{9}$/.test(sdtQuocTe)) {
                throw new Error('S·ªë ƒëi·ªán tho·∫°i kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng Vi·ªát Nam.');
            }

            console.log(`üì± Attempting to send SMS to: ${sdtQuocTe}`);
            console.log(`üìû From number: ${process.env.TWILIO_PHONE_NUMBER}`);
            console.log(`üîß Twilio Account SID: ${process.env.TWILIO_ACCOUNT_SID}`);

            // Test Twilio connection tr∆∞·ªõc khi g·ª≠i
            try {
                const account = await twilioClient.api.accounts(process.env.TWILIO_ACCOUNT_SID).fetch();
                console.log(`‚úÖ Twilio account status: ${account.status}`);
            } catch (connectionError) {
                console.error('‚ùå Twilio connection failed:', connectionError.message);
                throw new Error('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Twilio. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh.');
            }

            const message = await twilioClient.messages.create({
                body: `[BILLIONS GYM] M√£ OTP c·ªßa b·∫°n l√†: ${otp}. M√£ c√≥ hi·ªáu l·ª±c trong 5 ph√∫t. Kh√¥ng chia s·∫ª m√£ n√†y v·ªõi ai.`,
                from: process.env.TWILIO_PHONE_NUMBER,
                to: sdtQuocTe
            });

            messageSid = message.sid;
            console.log(`‚úÖ SMS sent successfully. Message SID: ${messageSid}`);
            smsSuccess = true;

        } catch (twilioError) {
            console.error('‚ùå Twilio SMS Error:', twilioError.message);
            console.error('‚ùå Error code:', twilioError.code);
            console.error('‚ùå Error details:', twilioError);

            // X·ª≠ l√Ω c√°c l·ªói c·ª• th·ªÉ c·ªßa Twilio
            if (twilioError.code === 21211) {
                throw new Error('S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá.');
            } else if (twilioError.code === 21614) {
                throw new Error('S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ªó tr·ª£ tin nh·∫Øn SMS.');
            } else if (twilioError.code === 63007) {
                throw new Error('S·ªë ƒëi·ªán tho·∫°i ƒë√£ b·ªã ch·∫∑n b·ªüi Twilio.');
            }

            // Trong m√¥i tr∆∞·ªùng development, v·∫´n cho ph√©p test m√† kh√¥ng c·∫ßn SMS th·∫≠t
            if (process.env.NODE_ENV === 'development') {
                console.log(`‚ö†Ô∏è  SMS failed in dev mode, but OTP saved: ${otp}`);
                smsSuccess = true; // Gi·∫£ l·∫≠p th√†nh c√¥ng trong dev mode
            } else {
                // Trong production, throw error n·∫øu SMS fail
                throw new Error(`Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn SMS: ${twilioError.message}`);
            }
        }

        if (smsSuccess) {
            return {
                success: true,
                message: 'M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng ƒë·∫øn s·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n.',
                phoneNumber: sdt,
                otpLength: 6,
                expiresIn: '5 ph√∫t',
                messageSid: messageSid
            };
        } else {
            throw new Error('Kh√¥ng th·ªÉ g·ª≠i m√£ OTP. Vui l√≤ng th·ª≠ l·∫°i sau.');
        }

    } catch (error) {
        console.error('‚ùå OTP Generation Error:', error.message);
        throw error;
    }
};

const xacThucOTP = async (sdt, otp) => {
    console.log(`üîç Looking for OTP: ${otp} for phone: ${sdt}`);

    // Ki·ªÉm tra format OTP
    if (!otp || otp.length !== 6 || !/^\d{6}$/.test(otp)) {
        throw new Error('M√£ OTP ph·∫£i c√≥ 6 ch·ªØ s·ªë.');
    }

    const otpRecord = await OTP.findOne({ sdt, otp });

    if (!otpRecord) {
        console.log(`‚ùå OTP not found in database for ${sdt}`);

        // Debug: ki·ªÉm tra t·∫•t c·∫£ OTP cho s·ªë ƒëi·ªán tho·∫°i n√†y
        const allOtpsForPhone = await OTP.find({ sdt });
        console.log(`üìã All OTPs for ${sdt}:`, allOtpsForPhone.map(o => ({ otp: o.otp, createdAt: o.createdAt })));

        throw new Error('M√£ OTP kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.');
    }

    // Ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n (5 ph√∫t)
    const now = new Date();
    const otpAge = now - otpRecord.createdAt;
    const maxAge = 5 * 60 * 1000; // 5 ph√∫t

    if (otpAge > maxAge) {
        console.log(`‚è∞ OTP expired for ${sdt}. Age: ${otpAge}ms, Max: ${maxAge}ms`);
        await OTP.deleteOne({ _id: otpRecord._id }); // X√≥a OTP h·∫øt h·∫°n
        throw new Error('M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.');
    }

    console.log(`‚úÖ OTP found and valid for ${sdt}`);

    // Kh√¥ng x√≥a OTP ·ªü ƒë√¢y, v√¨ n√≥ s·∫Ω c·∫ßn cho b∆∞·ªõc reset m·∫≠t kh·∫©u cu·ªëi c√πng
    return {
        success: true,
        message: 'X√°c th·ª±c OTP th√†nh c√¥ng.',
        phoneNumber: sdt,
        expiresAt: new Date(otpRecord.createdAt.getTime() + maxAge)
    };
};

const datLaiMatKhauVoiOTP = async (sdt, otp, matKhauMoi) => {
    try {
        console.log(`üîê Resetting password for ${sdt} with OTP: ${otp}`);

        // Ki·ªÉm tra format m·∫≠t kh·∫©u m·ªõi
        if (!matKhauMoi || matKhauMoi.length < 6) {
            throw new Error('M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±.');
        }

        // T√¨m OTP trong DB
        const otpRecord = await OTP.findOne({ sdt, otp });

        if (!otpRecord) {
            console.log(`‚ùå OTP not found for ${sdt}`);
            throw new Error('M√£ OTP kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.');
        }

        // Ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n OTP
        const now = new Date();
        const otpAge = now - otpRecord.createdAt;
        const maxAge = 5 * 60 * 1000; // 5 ph√∫t

        if (otpAge > maxAge) {
            console.log(`‚è∞ OTP expired for ${sdt}`);
            await OTP.deleteOne({ _id: otpRecord._id });
            throw new Error('M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.');
        }

        // T√¨m t√†i kho·∫£n
        const taiKhoan = await TaiKhoan.findOne({ sdt });
        if (!taiKhoan) {
            console.log(`‚ùå Account not found for ${sdt}`);
            throw new Error('Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n.');
        }

        // Ki·ªÉm tra m·∫≠t kh·∫©u m·ªõi c√≥ kh√°c m·∫≠t kh·∫©u c≈© kh√¥ng
        const isSamePassword = await bcrypt.compare(matKhauMoi, taiKhoan.matKhau);
        if (isSamePassword) {
            throw new Error('M·∫≠t kh·∫©u m·ªõi ph·∫£i kh√°c m·∫≠t kh·∫©u hi·ªán t·∫°i.');
        }

        // BƒÉm m·∫≠t kh·∫©u m·ªõi
        const salt = await bcrypt.genSalt(12);
        taiKhoan.matKhau = await bcrypt.hash(matKhauMoi, salt);
        await taiKhoan.save();

        console.log(`‚úÖ Password updated for ${sdt}`);

        // X√≥a OTP ƒë√£ s·ª≠ d·ª•ng
        await OTP.deleteOne({ _id: otpRecord._id });
        console.log(`üóëÔ∏è OTP deleted after successful password reset`);

        return {
            success: true,
            message: 'M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i th√†nh c√¥ng.',
            phoneNumber: sdt
        };

    } catch (error) {
        console.error('‚ùå Password Reset Error:', error.message);
        throw error;
    }
};

const findTaiKhoanByUserId = async (userId) => {
    console.log(`üîç Finding TaiKhoan for userId: ${userId}`);
    const taiKhoan = await TaiKhoan.findOne({ nguoiDung: userId });
    console.log(`üîç Found TaiKhoan:`, taiKhoan ? 'Yes' : 'No');
    return taiKhoan;
};

const updatePassword = async (taiKhoanId, hashedPassword) => {
    console.log(`üîß Updating password for TaiKhoan ID: ${taiKhoanId}`);
    const result = await TaiKhoan.findByIdAndUpdate(taiKhoanId, { matKhau: hashedPassword });
    console.log(`üîß Update result:`, result ? 'Success' : 'Failed');
    return result;
};

module.exports = {
    findTaiKhoanBySdt,
    findNguoiDungById,
    guiOTPQuenMatKhau,
    xacThucOTP,
    datLaiMatKhauVoiOTP,
    findTaiKhoanByUserId,
    updatePassword
};
